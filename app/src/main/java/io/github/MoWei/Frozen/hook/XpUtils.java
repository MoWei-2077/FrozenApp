package io.github.MoWei.Frozen.hook;import java.lang.reflect.Constructor;import java.lang.reflect.Field;import java.lang.reflect.Method;import java.util.Arrays;import de.robv.android.xposed.XC_MethodHook;import de.robv.android.xposed.XposedBridge;import de.robv.android.xposed.XposedHelpers;import io.github.MoWei.Frozen.Utils;public class XpUtils {    public final static boolean DEBUG_WAKEUP_LOCK = false;    public final static boolean DEBUG_BROADCAST_STATIC = false;    public final static boolean DEBUG_BROADCAST_DYNAMIC = false;    public final static boolean DEBUG_BROADCAST_INTENT = false;    public final static boolean DEBUG_ALARM = false;    public final static boolean DEBUG_ANR = false;    public final static boolean DEBUG_PENDING_UID  = false;    public final static boolean DEBUG_AUDIO_INTENT = false;    public final static boolean DEBUG_PENDING_INTENT = false;    public final static boolean DEBUG_AUDIO_UID = false;    static final int maxLogLength = 16000; // 16K 非KiB    public static StringBuilder xpLogContent = new StringBuilder(maxLogLength); // StringBuffer?    public static void log(final String TAG, final String content) {        // XposedBridge.log(TAG + content);        if (xpLogContent.length() + TAG.length() + content.length() + 20 > maxLogLength)            xpLogContent.setLength(0);        var timeStamp = System.currentTimeMillis() / 1000 + 8 * 3600; //UTC+8        var hour = (timeStamp / 3600) % 24;        var min = (timeStamp % 3600) / 60;        var sec = timeStamp % 60;        if(hour < 10) xpLogContent.append('0');        xpLogContent.append(hour).append(':');        if(min < 10) xpLogContent.append('0');        xpLogContent.append(min).append(':');        if(sec < 10) xpLogContent.append('0');        xpLogContent.append(sec).append(' ');        xpLogContent.append(TAG).append(": ").append(content).append('\n');    }    public static boolean hookMethod(String TAG, ClassLoader classLoader, XC_MethodHook callback,                                     String className, String methodName, Object... parameterTypes) {        Class<?> clazz = XposedHelpers.findClassIfExists(className, classLoader);        if (clazz == null) {            log(TAG, "⚠️Cannot hookMethod: " + methodName + ", cannot find " + className);            return false;        }        Method method = XposedHelpers.findMethodExactIfExists(clazz, methodName, parameterTypes);        if (method == null) {            log(TAG, "⚠️Cannot hookMethod: " + methodName);            return false;        }        XposedBridge.hookMethod(method, callback);        log(TAG, "Success hookMethod: " + methodName);        return true;    }    /**     * 在 clazz 中找名字为 methodName 的重载方法，     * 并且参数列表里必须包含 int.class ，     * 最终返回参数个数最多的那个 Method。     *     * @param clazz      目标类     * @param methodName 方法名     * @param mustInc    必须包含的参数类型（这里固定传 int.class ）     * @return 匹配的方法，或 null     */    public static Method tryLongestParams(Class<?> clazz,                                          String methodName,                                          Class<?> mustInc) {        if (clazz == null || methodName == null) {            return null;        }        Method best = null;        int maxLen = -1;        // 1. 拿到所有声明的方法（包括私有、保护、公开）        Method[] all = clazz.getDeclaredMethods();        for (Method m : all) {            // 名字必须一样            if (!m.getName().equals(methodName))  {                continue;            }            Class<?>[] pts = m.getParameterTypes();            // 2. 参数列表里必须出现 mustInc（int.class ）            boolean hit = false;            for (Class<?> p : pts) {                if (p == mustInc) {      // 基本类型用 == 比较即可                    hit = true;                    break;                }            }            if (!hit) {                continue;            }            // 3. 选参数最多的            if (pts.length  > maxLen) {                maxLen = pts.length;                best = m;            }        }        // 如果方法是 private/protected，外部想调用需要 setAccessible(true)        return best;    }    public static void hookConstructor(String TAG, ClassLoader classLoader, XC_MethodHook callback,                                       String className, Object... parameterTypes) {        Class<?> clazz = XposedHelpers.findClassIfExists(className, classLoader);        if (clazz == null) {            log(TAG, "⚠️Cannot hookConstructor, cannot find " + className);            return;        }        Constructor<?> constructor = XposedHelpers.findConstructorExact(clazz, parameterTypes);        if (constructor == null) {            log(TAG, "⚠️Cannot hookConstructor: " + className);            return;        }        XposedBridge.hookMethod(constructor, callback);        log(TAG, "Success hookConstructor: " + className);    }    public static int getInt(final Object obj, final String fieldName) {        try {            Field field = obj.getClass().getDeclaredField(fieldName);            field.setAccessible(true);            return field.getInt(obj);        } catch (Exception e) {            log("Frozen[getInt]", "获取失败 " + obj.getClass().getName() + "#" + fieldName + ": " + e);            return -1;        }    }    public static boolean getBoolean(final Object obj, final String fieldName) {        try {            Field field = obj.getClass().getDeclaredField(fieldName);            field.setAccessible(true);            return field.getBoolean(obj);        } catch (Exception e) {            log("Frozen[getBoolean]", "获取失败 " + obj.getClass().getName() + "#" + fieldName + ": " + e);            return false;        }    }    public static String getString(final Object obj, final String fieldName) {        try {            Field field = obj.getClass().getDeclaredField(fieldName);            field.setAccessible(true);            return (String) field.get(obj);        } catch (Exception e) {            log("Frozen[getString]", "获取失败 " + obj.getClass().getName() + "#" + fieldName + ": " + e);            return "null";        }    }    // 少量元素(0-10)时，clear,add,contain 性能均优于 HashSet, TreeSet    public static class VectorSet {        int size = 0, maxSize;        int[] vector;        public VectorSet(int maxSize) {            this.maxSize = maxSize;            vector = new int[maxSize];        }        public int size() {            return size;        }        public boolean isEmpty() {            return size == 0;        }        public void clear() {            size = 0;        }        public void add(final int n) {            for (int i = 0; i < size; i++) {                if (vector[i] == n) return;            }            if (size < maxSize)                vector[size++] = n;        }        public void erase(final int n) {            for (int i = 0; i < size; i++) {                if (vector[i] == n) {                    vector[i] = vector[--size];                    return;                }            }        }        // 顺序查找        public boolean contains(final int n) {            if (n < 10000) return false;            for (int i = 0; i < size; i++) {                if (vector[i] == n)                    return true;            }            return false;        }        public void toBytes(byte[] bytes, int byteOffset) {            if (size > 0)                Utils.Int2Byte(vector, 0, size, bytes, byteOffset);        }    }    // 造轮子：常见UID位于 10000 ~ 14000    // 在 APP UID 范围, 性能均优于HashSet    public static class BucketSet {        final int uidMin1 = 10000;        final int uidMax1 = 14000;        final boolean[] bucket1 = new boolean[uidMax1 - uidMin1];        int size = 0;        public int size() { return size; }        public boolean isEmpty() { return size == 0; }        public void clear() {            Arrays.fill(bucket1, false);            size = 0;        }        public void add(final int n) {            if (n >= uidMin1 && n < uidMax1) {                int idx = n - uidMin1;                if (!bucket1[idx]) {                    bucket1[idx] = true;                    size++;                }                return;            }        }        public void erase(final int n) {            if (n >= uidMin1 && n < uidMax1) {                int idx = n - uidMin1;                if (bucket1[idx]) {                    bucket1[idx] = false;                    size--;                }                return;            }        }        public boolean contains(final int n) {            if (n >= uidMin1 && n < uidMax1) {                return bucket1[n - uidMin1];            }            return false;        }    }}